<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nanoev (nanoev.Nanoev)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">nanoev</a> &#x00BB; Nanoev</nav><header class="odoc-preamble"><h1>Module <code><span>Nanoev</span></code></h1><p>Nano event loop.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#summary">Summary</a></li></ul></nav></div><div class="odoc-content"><h2 id="summary"><a href="#summary" class="anchor"></a>Summary</h2><p>Nanoev is a small abstraction over non-blocking IO event loops offered by most operating systems (e.g kqueue on BSD/macOS, poll on posix systems, epoll on linux, completion ports on windows).</p><p>The idea is that a <code>Nanoev.t</code> encapsulates a single event loop in a reusable form, and can be used in higher-level concurrency packages or to write async IO code directly. See <a href="../Nanoev_unix/index.html"><code>Nanoev_unix</code></a> for a <code>Unix.select</code>-based implementation and <code>Nanoev_posix</code> for a <code>poll</code>-based (better) implementation.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Closed"><a href="#exception-Closed" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Closed</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Impl"><a href="#module-Impl" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Impl/index.html">Impl</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Reset the state, similar to creating a new event loop from scratch</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wakeup_from_outside"><a href="#val-wakeup_from_outside" class="anchor"></a><code><span><span class="keyword">val</span> wakeup_from_outside : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Wakeup a sleeping event loop from the outside (another thread, a signal handler, etc.). This must be thread-safe.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-step"><a href="#val-step" class="anchor"></a><code><span><span class="keyword">val</span> step : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Run one step of the event loop until something happens. This can potentially block the caller for an interdeterminate duration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Close the file descriptor and clean it up inside the event loop. Callbacks registered on this FD will be called with <code>~closed:true</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max_fds"><a href="#val-max_fds" class="anchor"></a><code><span><span class="keyword">val</span> max_fds : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Maximum number of file descriptors that can be observed at once. This depends on the syscall underlying the event loop, as well as other system limits (see <code>ulimit -n</code> to change this limit on linux, for example).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_readable"><a href="#val-on_readable" class="anchor"></a><code><span><span class="keyword">val</span> on_readable : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="label">closed</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>on_readable nanoev fd x y f</code> registers <code>f x y</code> to be called when <code>fd</code> becomes readable. An additional <code>closed</code> parameter is passed to <code>f</code> to inform it of whether <code>fd</code> is <i>known</i> to be closed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_writable"><a href="#val-on_writable" class="anchor"></a><code><span><span class="keyword">val</span> on_writable : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../ocaml/Unix/index.html#type-file_descr">Unix.file_descr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="label">closed</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-on_readable"><code>on_readable</code></a> but calls <code>f</code> when the FD is writable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_after_s"><a href="#val-run_after_s" class="anchor"></a><code><span><span class="keyword">val</span> run_after_s : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>run_after_s nanoev [duration] x y f</code> registers <code>f x y</code> to be called after <code>duration</code> seconds have elapsed.</p></div></div></div></body></html>
